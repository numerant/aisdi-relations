/* Klasa Drzewo (nazwa robocza) tworząca strukturę 'drzewa multicastowego', które odtwarza drogę jednego maila. Interfejs graficzny będzie również korzystał z tej klasy to reprezentacji wizualnej zawartości tej klasy.
----------------------------------------------------------------------
Założenia:
	- Żeby przedstawianie tego w ten sposób miało sens, mail nie może być modyfikowany. Wszelki dopiski, czy cytowania przekreślają jego udział w tym drzewie, gdyż jest to już inny mail tak naprawdę.
	- Mail jest wczytywany tylko raz. Potem interesują nas już sami użytkownicy którzy go odebrali.
	- Jeżeli wystąpi cykl, czyli User1 prześle do User2, ten do User3, a ten spowrotem do User1, ostatni forward jest pomijany i rozpatrywany jako brak przesłania dalej dla User3 (chyba, że wysłał innym, wtedy rozpatrujemy). Jest to konieczne, by było to drzewo a nie graf. Po drugie, User1 już kiedyś miał tego maila. Treść się nie zmienia, więc nie potrzebuje kolejnej jego kopii.

Uwagi ogólne:
	- Wszystkie pola będą dynamicznie alokowane (new, delete). Konieczność zadbania o pełne zwolnienie pamięci.
	- Dla potwierdzenia
----------------------------------------------------------------------
>>> Class Email

> Pola:
	- Email * email 			//wskazanie na rozważanego emaila

	- struct Node				//węzeł drzewa
		- vector (Node*) 		//wektorek wskazań na następnych odbiorców (bo może być ich wielu)
		- Node* parent			//wskazanie na aktualnego nadawcę
		- User id				//id aktualnego usera
			/* a może  User* user  jako wskazanie? */

	opcjonalne pola w stylu 'height' czy 'elemCounter' mogą występować, lecz na tę chwilę nie mają specjalnego znaczenia implementacyjnego


> Metody:
	- getEmail (id lub wskazanie)   //bierze z bazy maila, którego będzie "rozpisywać"
									//metoda szuka takiego egzemplarza maila, który nie miał forwardu, żeby od niego iść w dół

	- createNode (parent)			//tworzy węzeł w dół od rodzica (zczytuje dane o userze, uaktualnia vector wskazań)

	- deleteNode (node)			    //usuwa podany węzeł i dowiązania do niego
									//możliwe usuwanie tylko węzłów, które nie mają "potomków"
									//inaczej stracimy wskazania do potomków (nie zwolnimy pamięci)

	- printEmail ()					//wyświetla informacje o emailu
	
	- printRoute ()					//wyświetla w formie tekstowej (np. zagnieżdżenia tabulacją) strukturę drzewa
									//sprawdzenie poprawności formy graficznej lub ewentualność na wypadek błędu
									
	- printUser (node) 				//(opcjonalnie) info o danym userze
									//wyswietlanie przy pomocy ID jest bez sensu, bo realizuje to Baza
----------------------------------------------------------------------

